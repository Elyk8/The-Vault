/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => AliasFromHeadingPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var AliasFromHeadingPlugin = class extends import_obsidian.Plugin {
  onload() {
    const { metadataCache, vault, workspace } = this.app;
    const headingByPath = new Map();
    function getHeading(file) {
      const { headings } = metadataCache.getFileCache(file);
      if (!Array.isArray(headings) || !headings.length) {
        return;
      }
      const { heading } = headings[0];
      return heading;
    }
    const clearHeadings = (0, import_obsidian.debounce)((path) => {
      if (!headingByPath.has(path)) {
        return;
      }
      const heading = headingByPath.get(path);
      headingByPath.clear();
      headingByPath.set(path, heading);
    }, 1e4, true);
    function loadFile(file) {
      const { path } = file;
      const heading = getHeading(file);
      headingByPath.set(path, heading);
      clearHeadings(path);
    }
    workspace.onLayoutReady(() => {
      const activeFile = workspace.getActiveFile();
      loadFile(activeFile);
    });
    this.registerEvent(workspace.on("file-open", loadFile));
    this.registerEvent(vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian.TFile)) {
        return;
      }
      const { path } = file;
      const heading = headingByPath.get(oldPath);
      headingByPath.set(path, heading);
    }));
    this.registerEvent(metadataCache.on("changed", (file) => __async(this, null, function* () {
      const { path } = file;
      if (!headingByPath.has(path)) {
        return;
      }
      const prevHeading = headingByPath.get(path);
      const heading = getHeading(file);
      headingByPath.set(path, heading);
      if (prevHeading === heading) {
        return;
      }
      const modifiedFiles = Object.entries(metadataCache.resolvedLinks).reduce((paths, [toPath, links]) => {
        const hasRef = Object.keys(links).includes(path);
        return hasRef ? [...paths, toPath] : paths;
      }, []).map((p) => {
        const { links = [] } = metadataCache.getCache(p);
        const linksToReplace = links.map((rc) => rc.link).filter((link) => link.split("#")[0] === metadataCache.fileToLinktext(file, "")).map((link) => [prevHeading, heading].map((h) => `[[${link}|${h === void 0 ? link : h}]]`));
        return [p, linksToReplace];
      }).filter(([, linksToReplace]) => linksToReplace.length).map((_0) => __async(this, [_0], function* ([p, linksToReplace]) {
        const f = vault.getAbstractFileByPath(p);
        const prevContents = yield vault.read(f);
        const [contents, matches] = linksToReplace.reduce(([source, total], [find, replace]) => {
          let count = 0;
          const re = new RegExp(escapeRegExp(find), "g");
          const s = source.replace(re, () => {
            count++;
            return replace;
          });
          return [s, count + total];
        }, [prevContents, 0]);
        yield vault.modify(f, contents);
        return matches;
      }));
      const linkMatches = (yield Promise.all(modifiedFiles)).filter((m) => m);
      const fileCount = linkMatches.length;
      const linkCount = linkMatches.reduce((sum, value) => sum + value, 0);
      if (!fileCount || !linkCount) {
        return;
      }
      new import_obsidian.Notice(`Updated ${linkCount} ${pluralize(linkCount, "link")} in ${fileCount} ${pluralize(fileCount, "file")}.`);
    })));
    this.removeMetadataCachePatch = patch(metadataCache, {
      getLinkSuggestions(originalMethod) {
        return function() {
          const delimiter = "|";
          const suggestions = originalMethod();
          const frontmatterAliases = suggestions.filter((suggestion) => suggestion.hasOwnProperty("path") && suggestion.hasOwnProperty("alias")).map(({ path, alias }) => [path, alias].join(delimiter));
          const suggestionsFromHeading = vault.getMarkdownFiles().map((file) => {
            const alias = getHeading(file);
            const path = omitExtension(file.path);
            if (!alias || frontmatterAliases.includes([path, alias].join(delimiter))) {
              return;
            }
            return { file, path, alias };
          }).filter((v) => v);
          return [...suggestions, ...suggestionsFromHeading];
        };
      }
    });
  }
  onunload() {
    this.removeMetadataCachePatch();
  }
};
function escapeRegExp(source) {
  return source.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function omitExtension(path) {
  const i = path.lastIndexOf(".");
  return i === -1 || i === path.length - 1 || i === 0 ? path : path.slice(0, i);
}
function patch(source, methods) {
  const removals = Object.entries(methods).map(([key, createMethod]) => {
    const hadOwn = source.hasOwnProperty(key);
    const method = source[key];
    source[key] = createMethod(method.bind(source));
    return function remove() {
      if (hadOwn) {
        source[key] = method;
      } else {
        delete source[key];
      }
    };
  });
  return () => removals.forEach((r) => r());
}
function pluralize(count, singular, plural = `${singular}s`) {
  return count === 1 ? singular : plural;
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgZGVib3VuY2UsIE5vdGljZSwgUGx1Z2luLCBSZWZlcmVuY2VDYWNoZSwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5cbmludGVyZmFjZSBMaW5rU3VnZ2VzdGlvbiB7XG5cdGZpbGU6IFRGaWxlO1xuXHRwYXRoOiBzdHJpbmc7XG5cdGFsaWFzPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbGlhc0Zyb21IZWFkaW5nUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0cmVtb3ZlTWV0YWRhdGFDYWNoZVBhdGNoOiAoKSA9PiB2b2lkO1xuXG5cdG9ubG9hZCAoKSB7XG5cdFx0Y29uc3QgeyBtZXRhZGF0YUNhY2hlLCB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRjb25zdCBoZWFkaW5nQnlQYXRoID0gbmV3IE1hcCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0SGVhZGluZyAoZmlsZTpURmlsZSkge1xuXHRcdFx0Y29uc3QgeyBoZWFkaW5ncyB9ID0gbWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoaGVhZGluZ3MpIHx8ICFoZWFkaW5ncy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgeyBoZWFkaW5nIH0gPSBoZWFkaW5nc1swXTtcblx0XHRcdHJldHVybiBoZWFkaW5nO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgYSBmaWxlIG9wZW5zLCBjbGVhciBvdXQgdGhlIG9sZCBkYXRhIGFmdGVyXG5cdFx0Ly8gYSBkZWJvdW5jZWQgMTAgc2Vjb25kcy4gVGhpcyBnaXZlcyBwbGVudHkgb2YgdGltZSBmb3Jcblx0XHQvLyBhbnkgbGlua3MgdG8gYmUgdXBkYXRlZCwgaWYgdGhlIHVzZXIgdXBkYXRlcyB0aGUgaGVhZGluZ1xuXHRcdC8vIGFuZCBxdWlja2x5IG9wZW5zIGFub3RoZXIgZmlsZS5cblx0XHRjb25zdCBjbGVhckhlYWRpbmdzID0gZGVib3VuY2UoKHBhdGgpID0+IHtcblx0XHRcdGlmICghaGVhZGluZ0J5UGF0aC5oYXMocGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgaGVhZGluZyA9IGhlYWRpbmdCeVBhdGguZ2V0KHBhdGgpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5jbGVhcigpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5zZXQocGF0aCwgaGVhZGluZyk7XG5cdFx0fSwgMTAwMDAsIHRydWUpO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZEZpbGUgKGZpbGU6VEZpbGUpIHtcblx0XHRcdGNvbnN0IHsgcGF0aCB9ID0gZmlsZTtcblx0XHRcdGNvbnN0IGhlYWRpbmcgPSBnZXRIZWFkaW5nKGZpbGUpO1xuXHRcdFx0aGVhZGluZ0J5UGF0aC5zZXQocGF0aCwgaGVhZGluZyk7XG5cdFx0XHRjbGVhckhlYWRpbmdzKHBhdGgpO1xuXHRcdH1cblxuXHRcdHdvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcblx0XHRcdGNvbnN0IGFjdGl2ZUZpbGUgPSB3b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXHRcdFx0bG9hZEZpbGUoYWN0aXZlRmlsZSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQod29ya3NwYWNlLm9uKCdmaWxlLW9wZW4nLCBsb2FkRmlsZSkpO1xuXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50KHZhdWx0Lm9uKCdyZW5hbWUnLCAoZmlsZSwgb2xkUGF0aCkgPT4ge1xuXHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCB7IHBhdGggfSA9IGZpbGU7XG5cdFx0XHRjb25zdCBoZWFkaW5nID0gaGVhZGluZ0J5UGF0aC5nZXQob2xkUGF0aCk7XG5cdFx0XHRoZWFkaW5nQnlQYXRoLnNldChwYXRoLCBoZWFkaW5nKTtcblx0XHR9KSk7XG5cblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQobWV0YWRhdGFDYWNoZS5vbignY2hhbmdlZCcsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRjb25zdCB7IHBhdGggfSA9IGZpbGU7XG5cblx0XHRcdGlmICghaGVhZGluZ0J5UGF0aC5oYXMocGF0aCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwcmV2SGVhZGluZyA9IGhlYWRpbmdCeVBhdGguZ2V0KHBhdGgpO1xuXHRcdFx0Y29uc3QgaGVhZGluZyA9IGdldEhlYWRpbmcoZmlsZSk7XG5cdFx0XHRoZWFkaW5nQnlQYXRoLnNldChwYXRoLCBoZWFkaW5nKTtcblxuXHRcdFx0aWYgKHByZXZIZWFkaW5nID09PSBoZWFkaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbW9kaWZpZWRGaWxlcyA9IE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhQ2FjaGUucmVzb2x2ZWRMaW5rcylcblx0XHRcdFx0LnJlZHVjZSgocGF0aHMsIFt0b1BhdGgsIGxpbmtzXSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGhhc1JlZiA9IE9iamVjdC5rZXlzKGxpbmtzKS5pbmNsdWRlcyhwYXRoKTtcblx0XHRcdFx0XHRyZXR1cm4gaGFzUmVmID8gWy4uLnBhdGhzLCB0b1BhdGhdIDogcGF0aHM7XG5cdFx0XHRcdH0sIFtdKVxuXHRcdFx0XHQubWFwKChwOnN0cmluZykgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHsgbGlua3MgPSBbXSB9ID0gbWV0YWRhdGFDYWNoZS5nZXRDYWNoZShwKTtcblx0XHRcdFx0XHRjb25zdCBsaW5rc1RvUmVwbGFjZSA9IGxpbmtzXG5cdFx0XHRcdFx0XHQubWFwKChyYzpSZWZlcmVuY2VDYWNoZSkgPT4gcmMubGluaylcblx0XHRcdFx0XHRcdC5maWx0ZXIoKGxpbmspID0+IGxpbmsuc3BsaXQoJyMnKVswXSA9PT0gbWV0YWRhdGFDYWNoZS5maWxlVG9MaW5rdGV4dChmaWxlLCAnJykpXG5cdFx0XHRcdFx0XHQvLyBNYWtlIHBhaXJzIG9mIGxpbmtzIHRvIGJlIGZvdW5kIGFuZCByZXBsYWNlZC5cblx0XHRcdFx0XHRcdC8vIFNvbWUgb2YgdGhlc2UgcGFpcnMgbWF5IGJlIHJlZHVuZGFudCBvciByZXN1bHQgaW4gbm8gbWF0Y2hlc1xuXHRcdFx0XHRcdFx0Ly8gZm9yIGFueSBnaXZlbiBwYXRoLCBidXQgdGhhdCdzIG9rYXkuXG5cdFx0XHRcdFx0XHQvLyBUaGUgYHJjLm9yaWdpbmFsYCBhbmQgYHJjLmRpc3BsYXlUZXh0YCB2YWx1ZXMgYXJlIG5vdCB1c2VkLFxuXHRcdFx0XHRcdFx0Ly8gYmVjYXVzZSBpdCBjb3VsZCBiZSBpbmFjY3VyYXRlIGlmIHRoZSBoZWFkaW5nIGVuZHMgd2l0aCBhIGBdYC5cblx0XHRcdFx0XHRcdC8vIFRoZSBPYnNpZGlhbiBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBsaW5rcyBpcyBjb3JyZWN0LFxuXHRcdFx0XHRcdFx0Ly8gYnV0IHRoaXMgZXh0cmEgd29yayBpcyBuZWVkZWQgdG8gbWF0Y2ggdG8gdGhlIHVzZXIgaW50ZW50LlxuXHRcdFx0XHRcdFx0Lm1hcCgobGluaykgPT5cblx0XHRcdFx0XHRcdFx0W3ByZXZIZWFkaW5nLCBoZWFkaW5nXVxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKGgpID0+IGBbWyR7bGlua318JHtoID09PSB1bmRlZmluZWQgPyBsaW5rIDogaH1dXWApXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0cmV0dXJuIFtwLCBsaW5rc1RvUmVwbGFjZV07XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5maWx0ZXIoKFssIGxpbmtzVG9SZXBsYWNlXTpbc3RyaW5nLCBbXV0pID0+IGxpbmtzVG9SZXBsYWNlLmxlbmd0aClcblx0XHRcdFx0Lm1hcChhc3luYyAoW3AsIGxpbmtzVG9SZXBsYWNlXTpbc3RyaW5nLCBbXV0pID0+IHtcblx0XHRcdFx0XHRjb25zdCBmID0gPFRGaWxlPnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwKTtcblx0XHRcdFx0XHRjb25zdCBwcmV2Q29udGVudHMgPSBhd2FpdCB2YXVsdC5yZWFkKGYpO1xuXHRcdFx0XHRcdGNvbnN0IFtjb250ZW50cywgbWF0Y2hlc106KHN0cmluZyB8IG51bWJlcilbXSA9IGxpbmtzVG9SZXBsYWNlLnJlZHVjZShcblx0XHRcdFx0XHRcdChbc291cmNlLCB0b3RhbF06W3N0cmluZywgbnVtYmVyXSwgW2ZpbmQsIHJlcGxhY2VdOnN0cmluZ1tdKSA9PiB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBoZWFkaW5nIG11c3QgYmUgYSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIG5vdCBhIHN0cmluZy5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBzb2x2ZXMgdHdvIHByb2JsZW1zIHdpdGggdGhlIHVzZSBvZiBgU3RyaW5nLnJlcGxhY2UoKWAuXG5cdFx0XHRcdFx0XHRcdC8vIDEuIFRoaXMgYWxsb3dzIHJlcGxhY2VtZW50IHBhdHRlcm5zIChgJCQsIGAkJmAsIGV0Yy4pXG5cdFx0XHRcdFx0XHRcdC8vICAgIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBoZWFkaW5nIHdpdGhvdXQgY2F1c2luZyBtaXNtYXRjaGVzLFxuXHRcdFx0XHRcdFx0XHQvLyAgICBzaW1pbGFyIHRvIHRoZSBhZm9yZW1lbnRpb25lZCBgXWAgcHJvYmxlbS5cblx0XHRcdFx0XHRcdFx0Ly8gMi4gVGhpcyBhbGxvd3MgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYmUgYSBmdW5jdGlvbixcblx0XHRcdFx0XHRcdFx0Ly8gICAgc28gdGhlIG51bWJlciBvZiBtYXRjaGVzIGNhbiBiZSBjb3VudGVkIGFzIGEgc2lkZSBlZmZlY3QuXG5cdFx0XHRcdFx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoZmluZCksICdnJyk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHMgPSBzb3VyY2UucmVwbGFjZShyZSwgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlcGxhY2U7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gW3MsIGNvdW50ICsgdG90YWxdO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFtwcmV2Q29udGVudHMsIDBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRhd2FpdCB2YXVsdC5tb2RpZnkoZiwgPHN0cmluZz5jb250ZW50cyk7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXM7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBsaW5rTWF0Y2hlcyA9IChhd2FpdCBQcm9taXNlLmFsbChtb2RpZmllZEZpbGVzKSlcblx0XHRcdFx0LmZpbHRlcigobSkgPT4gbSk7XG5cdFx0XHRjb25zdCBmaWxlQ291bnQgPSBsaW5rTWF0Y2hlcy5sZW5ndGg7XG5cdFx0XHRjb25zdCBsaW5rQ291bnQgPSBsaW5rTWF0Y2hlc1xuXHRcdFx0XHQucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCk7XG5cblx0XHRcdGlmICghZmlsZUNvdW50IHx8ICFsaW5rQ291bnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRuZXcgTm90aWNlKGBVcGRhdGVkICR7bGlua0NvdW50fSAke3BsdXJhbGl6ZShsaW5rQ291bnQsICdsaW5rJyl9IGluICR7ZmlsZUNvdW50fSAke3BsdXJhbGl6ZShmaWxlQ291bnQsICdmaWxlJyl9LmApO1xuXHRcdH0pKTtcblxuXHRcdC8vIEV4dGVuZCB0aGUgYGdldExpbmtTdWdnZXN0aW9uc2AgbWV0aG9kIHRvIGluY2x1ZGUgYWxpYXNlc1xuXHRcdC8vIGRlcml2ZWQgZnJvbSBoZWFkaW5ncy5cblx0XHR0aGlzLnJlbW92ZU1ldGFkYXRhQ2FjaGVQYXRjaCA9IHBhdGNoKG1ldGFkYXRhQ2FjaGUsIHtcblx0XHRcdGdldExpbmtTdWdnZXN0aW9ucyAob3JpZ2luYWxNZXRob2Q6ICgpID0+IExpbmtTdWdnZXN0aW9uW10pIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjb25zdCBkZWxpbWl0ZXIgPSAnfCc7XG5cdFx0XHRcdFx0Y29uc3Qgc3VnZ2VzdGlvbnMgPSBvcmlnaW5hbE1ldGhvZCgpO1xuXHRcdFx0XHRcdGNvbnN0IGZyb250bWF0dGVyQWxpYXNlcyA9IHN1Z2dlc3Rpb25zXG5cdFx0XHRcdFx0XHQuZmlsdGVyKChzdWdnZXN0aW9uKSA9PiBzdWdnZXN0aW9uLmhhc093blByb3BlcnR5KCdwYXRoJykgJiYgc3VnZ2VzdGlvbi5oYXNPd25Qcm9wZXJ0eSgnYWxpYXMnKSlcblx0XHRcdFx0XHRcdC5tYXAoKHsgcGF0aCwgYWxpYXMgfSkgPT4gW3BhdGgsIGFsaWFzXS5qb2luKGRlbGltaXRlcikpO1xuXHRcdFx0XHRcdGNvbnN0IHN1Z2dlc3Rpb25zRnJvbUhlYWRpbmcgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcblx0XHRcdFx0XHRcdC5tYXAoKGZpbGUpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYWxpYXMgPSBnZXRIZWFkaW5nKGZpbGUpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwYXRoID0gb21pdEV4dGVuc2lvbihmaWxlLnBhdGgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWFsaWFzIHx8IGZyb250bWF0dGVyQWxpYXNlcy5pbmNsdWRlcyhbcGF0aCwgYWxpYXNdLmpvaW4oZGVsaW1pdGVyKSkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgZmlsZSwgcGF0aCwgYWxpYXMgfTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuZmlsdGVyKCh2KSA9PiB2KTtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnN1Z2dlc3Rpb25zLCAuLi5zdWdnZXN0aW9uc0Zyb21IZWFkaW5nXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0b251bmxvYWQgKCkge1xuXHRcdHRoaXMucmVtb3ZlTWV0YWRhdGFDYWNoZVBhdGNoKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzb3VyY2U6c3RyaW5nKTpzdHJpbmcge1xuXHRyZXR1cm4gc291cmNlLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIG9taXRFeHRlbnNpb24gKHBhdGg6IHN0cmluZykge1xuXHRjb25zdCBpID0gcGF0aC5sYXN0SW5kZXhPZignLicpO1xuXHRyZXR1cm4gLTEgPT09IGkgfHwgaSA9PT0gcGF0aC5sZW5ndGggLSAxIHx8IDAgPT09IGkgPyBwYXRoIDogcGF0aC5zbGljZSgwLCBpKTtcbn1cblxuLy8gSW5zcGlyZWQgYnk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGplYnkvbW9ua2V5LWFyb3VuZFxuZnVuY3Rpb24gcGF0Y2ggKHNvdXJjZTphbnksIG1ldGhvZHM6YW55KSB7XG5cdGNvbnN0IHJlbW92YWxzID0gT2JqZWN0LmVudHJpZXMobWV0aG9kcykubWFwKChba2V5LCBjcmVhdGVNZXRob2RdKSA9PiB7XG5cdFx0Y29uc3QgaGFkT3duID0gc291cmNlLmhhc093blByb3BlcnR5KGtleSk7XG5cdFx0Y29uc3QgbWV0aG9kID0gc291cmNlW2tleV07XG5cdFx0c291cmNlW2tleV0gPSBjcmVhdGVNZXRob2QobWV0aG9kLmJpbmQoc291cmNlKSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVtb3ZlICgpIHtcblx0XHRcdGlmIChoYWRPd24pIHtcblx0XHRcdFx0c291cmNlW2tleV0gPSBtZXRob2Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgc291cmNlW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9KVxuXHRyZXR1cm4gKCkgPT4gcmVtb3ZhbHMuZm9yRWFjaCgocikgPT4gcigpKVxufVxuXG5mdW5jdGlvbiBwbHVyYWxpemUgKGNvdW50Om51bWJlciwgc2luZ3VsYXI6c3RyaW5nLCBwbHVyYWwgPSBgJHtzaW5ndWxhcn1zYCk6c3RyaW5nIHtcblx0cmV0dXJuIGNvdW50ID09PSAxID8gc2luZ3VsYXIgOiBwbHVyYWw7XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFnRTtBQVFoRSwyQ0FBb0QsdUJBQU87QUFBQSxFQUcxRCxTQUFVO0FBQ1QsVUFBTSxFQUFFLGVBQWUsT0FBTyxjQUFjLEtBQUs7QUFDakQsVUFBTSxnQkFBZ0IsSUFBSTtBQUUxQix3QkFBcUIsTUFBWTtBQUNoQyxZQUFNLEVBQUUsYUFBYSxjQUFjLGFBQWE7QUFDaEQsVUFBSSxDQUFDLE1BQU0sUUFBUSxhQUFhLENBQUMsU0FBUyxRQUFRO0FBQ2pEO0FBQUE7QUFFRCxZQUFNLEVBQUUsWUFBWSxTQUFTO0FBQzdCLGFBQU87QUFBQTtBQU9SLFVBQU0sZ0JBQWdCLDhCQUFTLENBQUMsU0FBUztBQUN4QyxVQUFJLENBQUMsY0FBYyxJQUFJLE9BQU87QUFDN0I7QUFBQTtBQUVELFlBQU0sVUFBVSxjQUFjLElBQUk7QUFDbEMsb0JBQWM7QUFDZCxvQkFBYyxJQUFJLE1BQU07QUFBQSxPQUN0QixLQUFPO0FBRVYsc0JBQW1CLE1BQVk7QUFDOUIsWUFBTSxFQUFFLFNBQVM7QUFDakIsWUFBTSxVQUFVLFdBQVc7QUFDM0Isb0JBQWMsSUFBSSxNQUFNO0FBQ3hCLG9CQUFjO0FBQUE7QUFHZixjQUFVLGNBQWMsTUFBTTtBQUM3QixZQUFNLGFBQWEsVUFBVTtBQUM3QixlQUFTO0FBQUE7QUFHVixTQUFLLGNBQWMsVUFBVSxHQUFHLGFBQWE7QUFFN0MsU0FBSyxjQUFjLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxZQUFZO0FBQ3hELFVBQUksQ0FBRSxpQkFBZ0Isd0JBQVE7QUFDN0I7QUFBQTtBQUVELFlBQU0sRUFBRSxTQUFTO0FBQ2pCLFlBQU0sVUFBVSxjQUFjLElBQUk7QUFD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
